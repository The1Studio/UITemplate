using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using System.IO;

namespace HeurekaGames.AssetHunterPRO.BaseTreeviewImpl.AssetTreeView
{
    [Serializable]
    public class AH_BuildInfoTreeView : ScriptableObject, ISerializationCallbackReceiver
    {
        //Serialization helper lists
        private List<string>  serializationHelperListIconTypes;
        private List<Texture> serializationHelperListIconTextures;

        [SerializeField] private List<AH_TreeviewElement> m_TreeElements;

        internal List<AH_TreeviewElement> treeElements { get => this.m_TreeElements; set => this.m_TreeElements = value; }

        public void OnEnable()
        {
            this.hideFlags = HideFlags.HideAndDontSave;
        }

        public bool PopulateTreeView(AH_SerializedBuildInfo chosenBuildInfo)
        {
            //Todo, maybe not get ALL assets, but just the assets in the project folder (i.e. -meta etc)?
            this.treeElements = new();

            var depth = -1;
            var id    = 0;

            var root = new AH_TreeviewElement("Root", depth, id, "", "", new(), false);

            this.treeElements.Add(root);

            depth++;
            id++;

            //This is done because I cant find all assets in toplevel folders through the Unity API (Remove whem the API allows it)
            var folderCount      = Directory.GetDirectories(Application.dataPath, "*", SearchOption.AllDirectories).Count();
            var foldersProcessed = 0;

            var populatedSuccesfully = this.AddFilesRecursively(Application.dataPath, chosenBuildInfo, depth, ref id, folderCount, ref foldersProcessed);

            //Cleanup garbage
            AssetDatabase.Refresh();
            GC.Collect();

            //Create tree
            if (populatedSuccesfully) TreeElementUtility.ListToTree(this.treeElements);

            EditorUtility.ClearProgressBar();

            return populatedSuccesfully;
        }

        private bool AddFilesRecursively(string absPath, AH_SerializedBuildInfo chosenBuildInfo, int treeViewDepth, ref int treeViewID, int folderCount, ref int foldersProcessed)
        {
            string relativePath;
            string folderID;
            AH_Utils.GetRelativePathAndAssetID(absPath, out relativePath, out folderID);

            //For some reason streamingassets folders are generated by unity when building, only to be deleted immediately after. Need to take that under consideration here.
            if (!AssetDatabase.IsValidFolder(relativePath)) return false;

            //Increment folder process count
            foldersProcessed++;
            var progress = (float)((float)foldersProcessed / (float)folderCount);
            EditorUtility.DisplayProgressBar($"Analyzing project ({foldersProcessed}/{folderCount}", relativePath, progress); //Todo make cancellable

            //Check if this folder has been Ignored
            if (AH_SettingsManager.Instance.HasIgnoredFolder(relativePath, folderID)) return false;

            //Add folder
            var dirInfo     = new DirectoryInfo(absPath);
            var dirInfoName = dirInfo.Name;

            //Increment ID
            treeViewID++;

            //TODO creating new treeviewelements loads asset from memory...DONT DO THAT!! Get filesize info somewhere else
            var threeViewFolder = new AH_TreeviewElement(dirInfoName, treeViewDepth, treeViewID, treeViewDepth != -1 ? relativePath : "", "", null, false);
            this.treeElements.Add(threeViewFolder);

            //Increment depth
            treeViewDepth++;

            //Track if this folder has valid children
            var hasValidChildren = false;

            foreach (var assetPath in Directory.GetFiles(absPath).Where(val => Path.GetExtension(val) != ".meta")) // !val.EndsWith(".meta")))
            {
                string relativepath;
                string assetID;
                AH_Utils.GetRelativePathAndAssetID(assetPath, out relativepath, out assetID);

                //If this is not an unity asset
                if (string.IsNullOrEmpty(assetID)) continue;

                //Has this file been Ignored?
                if (AH_SettingsManager.Instance.HasIgnoredAsset(relativepath, assetID)) continue;

                var usedAssetInfo = chosenBuildInfo.GetItemInfo(assetID);
                var isAssetUsed   = usedAssetInfo != null;

                //TODO CONTINUE LOOP AND ADDING OF ASSETS
                treeViewID++;
                var treeViewElement = new AH_TreeviewElement(assetPath, treeViewDepth, treeViewID, relativepath, assetID, isAssetUsed ? usedAssetInfo.Refs : null, isAssetUsed);
                this.treeElements.Add(treeViewElement);

                hasValidChildren = true;
            }

            foreach (var dir in Directory.GetDirectories(absPath))
                if (this.AddFilesRecursively(dir, chosenBuildInfo, treeViewDepth, ref treeViewID, folderCount, ref foldersProcessed))
                    hasValidChildren = true;

            if (!hasValidChildren && treeViewDepth != -1)
            {
                this.treeElements.Remove(threeViewFolder);
                //Decrement ID
                treeViewID--;

                //Decrement depth
                treeViewDepth--;
            }

            //Return true if folder added succesfully
            return hasValidChildren;
        }

        internal bool HasUnused()
        {
            var hasUnused = this.m_TreeElements.Any(val => !val.UsedInBuild && !val.IsFolder && val.depth != -1);
            return hasUnused;
        }

        private string[] getAssetsOfType(Type type)
        {
            return AssetDatabase.FindAssets("t:" + type.Name);
        }

        #region Serialization callbacks

        //Store serializable string so we can retrieve type after serialization
        public void OnBeforeSerialize()
        {
            this.serializationHelperListIconTypes    = AH_TreeviewElement.GetStoredIconTypes();
            this.serializationHelperListIconTextures = AH_TreeviewElement.GetStoredIconTextures();
        }

        public void OnAfterDeserialize()
        {
            AH_TreeviewElement.UpdateIconDictAfterSerialization(this.serializationHelperListIconTypes, this.serializationHelperListIconTextures);
            this.serializationHelperListIconTypes    = null;
            this.serializationHelperListIconTextures = null;
        }

        #endregion
    }
}